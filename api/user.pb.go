// Code generated by protoc-gen-go. DO NOT EDIT.
// source: user.proto

package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Defines the organizations that the user is associated with.
type OrganizationLink struct {
	OrganizationID   int64  `protobuf:"varint,1,opt,name=organizationID" json:"organizationID,omitempty"`
	OrganizationName string `protobuf:"bytes,2,opt,name=organizationName" json:"organizationName,omitempty"`
	IsAdmin          bool   `protobuf:"varint,3,opt,name=isAdmin" json:"isAdmin,omitempty"`
	CreatedAt        string `protobuf:"bytes,4,opt,name=createdAt" json:"createdAt,omitempty"`
	UpdatedAt        string `protobuf:"bytes,5,opt,name=updatedAt" json:"updatedAt,omitempty"`
}

func (m *OrganizationLink) Reset()                    { *m = OrganizationLink{} }
func (m *OrganizationLink) String() string            { return proto.CompactTextString(m) }
func (*OrganizationLink) ProtoMessage()               {}
func (*OrganizationLink) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

func (m *OrganizationLink) GetOrganizationID() int64 {
	if m != nil {
		return m.OrganizationID
	}
	return 0
}

func (m *OrganizationLink) GetOrganizationName() string {
	if m != nil {
		return m.OrganizationName
	}
	return ""
}

func (m *OrganizationLink) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

func (m *OrganizationLink) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *OrganizationLink) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

// The request for profile requires not input as the profile is returned for
// the logged in user based on the JWT token passed in.
type ProfileRequest struct {
}

func (m *ProfileRequest) Reset()                    { *m = ProfileRequest{} }
func (m *ProfileRequest) String() string            { return proto.CompactTextString(m) }
func (*ProfileRequest) ProtoMessage()               {}
func (*ProfileRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

// The user's profile. This specifies the access the user has to the data
// and should be used limit what the UI presents as options (e.g., read-only
// access to an application should not allow an "edit" button on that
// application).
type ProfileResponse struct {
	User          *GetUserResponse    `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	Organizations []*OrganizationLink `protobuf:"bytes,3,rep,name=organizations" json:"organizations,omitempty"`
	Settings      *ProfileSettings    `protobuf:"bytes,4,opt,name=settings" json:"settings,omitempty"`
}

func (m *ProfileResponse) Reset()                    { *m = ProfileResponse{} }
func (m *ProfileResponse) String() string            { return proto.CompactTextString(m) }
func (*ProfileResponse) ProtoMessage()               {}
func (*ProfileResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{2} }

func (m *ProfileResponse) GetUser() *GetUserResponse {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ProfileResponse) GetOrganizations() []*OrganizationLink {
	if m != nil {
		return m.Organizations
	}
	return nil
}

func (m *ProfileResponse) GetSettings() *ProfileSettings {
	if m != nil {
		return m.Settings
	}
	return nil
}

type ProfileSettings struct {
	// Existing users in the system can not be assigned to organizations and
	// application and can not be listed by non global admin users.
	DisableAssignExistingUsers bool `protobuf:"varint,1,opt,name=disableAssignExistingUsers" json:"disableAssignExistingUsers,omitempty"`
}

func (m *ProfileSettings) Reset()                    { *m = ProfileSettings{} }
func (m *ProfileSettings) String() string            { return proto.CompactTextString(m) }
func (*ProfileSettings) ProtoMessage()               {}
func (*ProfileSettings) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{3} }

func (m *ProfileSettings) GetDisableAssignExistingUsers() bool {
	if m != nil {
		return m.DisableAssignExistingUsers
	}
	return false
}

// The data for logging in to the system.  The connection is expected to be
// protected by SSL, allowing us to use the username and password in the clear.
type LoginRequest struct {
	// Username of the user.
	Username string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	// Password of the user.
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *LoginRequest) Reset()                    { *m = LoginRequest{} }
func (m *LoginRequest) String() string            { return proto.CompactTextString(m) }
func (*LoginRequest) ProtoMessage()               {}
func (*LoginRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{4} }

func (m *LoginRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *LoginRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// The response to the login request upon success. The jwt token is to be
// placed in the header field named "Grpc-Metadata-Authorization" for all
// subsequent queries to the server.
type LoginResponse struct {
	// The JWT tag to be used to access lora-app-server interfaces.
	Jwt string `protobuf:"bytes,1,opt,name=jwt" json:"jwt,omitempty"`
}

func (m *LoginResponse) Reset()                    { *m = LoginResponse{} }
func (m *LoginResponse) String() string            { return proto.CompactTextString(m) }
func (*LoginResponse) ProtoMessage()               {}
func (*LoginResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{5} }

func (m *LoginResponse) GetJwt() string {
	if m != nil {
		return m.Jwt
	}
	return ""
}

// Request the users defined in the system.
type ListUserRequest struct {
	// Max number of user to return in the result-set.
	Limit int32 `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
	// Offset in the result-set (for pagination).
	Offset int32 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	// When provided, the given string will be used to search on username.
	Search string `protobuf:"bytes,3,opt,name=search" json:"search,omitempty"`
}

func (m *ListUserRequest) Reset()                    { *m = ListUserRequest{} }
func (m *ListUserRequest) String() string            { return proto.CompactTextString(m) }
func (*ListUserRequest) ProtoMessage()               {}
func (*ListUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{6} }

func (m *ListUserRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListUserRequest) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ListUserRequest) GetSearch() string {
	if m != nil {
		return m.Search
	}
	return ""
}

// Request the user information.
type UserRequest struct {
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *UserRequest) Reset()                    { *m = UserRequest{} }
func (m *UserRequest) String() string            { return proto.CompactTextString(m) }
func (*UserRequest) ProtoMessage()               {}
func (*UserRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{7} }

func (m *UserRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type AddUserResponse struct {
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *AddUserResponse) Reset()                    { *m = AddUserResponse{} }
func (m *AddUserResponse) String() string            { return proto.CompactTextString(m) }
func (*AddUserResponse) ProtoMessage()               {}
func (*AddUserResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{8} }

func (m *AddUserResponse) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// User data not including the data access profile.
type UserSettings struct {
	// ID of the user.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Username of the user.
	Username string `protobuf:"bytes,2,opt,name=username" json:"username,omitempty"`
	// The session timeout, in minutes.
	SessionTTL int32 `protobuf:"varint,3,opt,name=sessionTTL" json:"sessionTTL,omitempty"`
	// If the user is a system admin, capable of creating other users.
	IsAdmin bool `protobuf:"varint,4,opt,name=isAdmin" json:"isAdmin,omitempty"`
	// If the user is active.
	IsActive bool `protobuf:"varint,5,opt,name=isActive" json:"isActive,omitempty"`
	// When the user was created.
	CreatedAt string `protobuf:"bytes,6,opt,name=createdAt" json:"createdAt,omitempty"`
	// When the user was last updated (excludes changes in application access).
	UpdatedAt string `protobuf:"bytes,7,opt,name=updatedAt" json:"updatedAt,omitempty"`
}

func (m *UserSettings) Reset()                    { *m = UserSettings{} }
func (m *UserSettings) String() string            { return proto.CompactTextString(m) }
func (*UserSettings) ProtoMessage()               {}
func (*UserSettings) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{9} }

func (m *UserSettings) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UserSettings) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserSettings) GetSessionTTL() int32 {
	if m != nil {
		return m.SessionTTL
	}
	return 0
}

func (m *UserSettings) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

func (m *UserSettings) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *UserSettings) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *UserSettings) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type GetUserResponse struct {
	// ID of the user.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Username of the user.
	Username string `protobuf:"bytes,2,opt,name=username" json:"username,omitempty"`
	// The session timeout, in minutes.
	SessionTTL int32 `protobuf:"varint,3,opt,name=sessionTTL" json:"sessionTTL,omitempty"`
	// If the user is a system admin, capable of creating other users.
	IsAdmin bool `protobuf:"varint,4,opt,name=isAdmin" json:"isAdmin,omitempty"`
	// If the user is active.
	IsActive bool `protobuf:"varint,5,opt,name=isActive" json:"isActive,omitempty"`
	// When the user was created.
	CreatedAt string `protobuf:"bytes,6,opt,name=createdAt" json:"createdAt,omitempty"`
	// When the user was last updated (excludes changes in application access).
	UpdatedAt string `protobuf:"bytes,7,opt,name=updatedAt" json:"updatedAt,omitempty"`
}

func (m *GetUserResponse) Reset()                    { *m = GetUserResponse{} }
func (m *GetUserResponse) String() string            { return proto.CompactTextString(m) }
func (*GetUserResponse) ProtoMessage()               {}
func (*GetUserResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{10} }

func (m *GetUserResponse) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GetUserResponse) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GetUserResponse) GetSessionTTL() int32 {
	if m != nil {
		return m.SessionTTL
	}
	return 0
}

func (m *GetUserResponse) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

func (m *GetUserResponse) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *GetUserResponse) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *GetUserResponse) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

// Add a new user. Not quite the UserSettings data as it includes a password
// and excludes the ID and create/update dates.
type AddUserRequest struct {
	// Username of the user.
	Username string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	// Passowrd of the user.
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	// The session timeout, in minutes.
	SessionTTL int32 `protobuf:"varint,3,opt,name=sessionTTL" json:"sessionTTL,omitempty"`
	// If the user is a system-wide admin.
	IsAdmin bool `protobuf:"varint,4,opt,name=isAdmin" json:"isAdmin,omitempty"`
	// If the user is active.
	IsActive bool `protobuf:"varint,5,opt,name=isActive" json:"isActive,omitempty"`
	// Add the user to the following organizations.
	Organizations []*AddUserOrganization `protobuf:"bytes,6,rep,name=organizations" json:"organizations,omitempty"`
}

func (m *AddUserRequest) Reset()                    { *m = AddUserRequest{} }
func (m *AddUserRequest) String() string            { return proto.CompactTextString(m) }
func (*AddUserRequest) ProtoMessage()               {}
func (*AddUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{11} }

func (m *AddUserRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AddUserRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *AddUserRequest) GetSessionTTL() int32 {
	if m != nil {
		return m.SessionTTL
	}
	return 0
}

func (m *AddUserRequest) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

func (m *AddUserRequest) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *AddUserRequest) GetOrganizations() []*AddUserOrganization {
	if m != nil {
		return m.Organizations
	}
	return nil
}

type AddUserOrganization struct {
	// ID of the organization.
	OrganizationID int64 `protobuf:"varint,1,opt,name=organizationID" json:"organizationID,omitempty"`
	// User has admin rights within the organization.
	IsAdmin bool `protobuf:"varint,2,opt,name=isAdmin" json:"isAdmin,omitempty"`
}

func (m *AddUserOrganization) Reset()                    { *m = AddUserOrganization{} }
func (m *AddUserOrganization) String() string            { return proto.CompactTextString(m) }
func (*AddUserOrganization) ProtoMessage()               {}
func (*AddUserOrganization) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{12} }

func (m *AddUserOrganization) GetOrganizationID() int64 {
	if m != nil {
		return m.OrganizationID
	}
	return 0
}

func (m *AddUserOrganization) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

// Not quite the AddUserRequest as no password.
type UpdateUserRequest struct {
	// The ID of the user to be updated.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// The new username.
	Username string `protobuf:"bytes,2,opt,name=username" json:"username,omitempty"`
	// The session timeout, in minutes.
	SessionTTL int32 `protobuf:"varint,3,opt,name=sessionTTL" json:"sessionTTL,omitempty"`
	// If the user is a system-wide admin.
	IsAdmin bool `protobuf:"varint,4,opt,name=isAdmin" json:"isAdmin,omitempty"`
	// If the user is active.
	IsActive bool `protobuf:"varint,5,opt,name=isActive" json:"isActive,omitempty"`
}

func (m *UpdateUserRequest) Reset()                    { *m = UpdateUserRequest{} }
func (m *UpdateUserRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateUserRequest) ProtoMessage()               {}
func (*UpdateUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{13} }

func (m *UpdateUserRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdateUserRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UpdateUserRequest) GetSessionTTL() int32 {
	if m != nil {
		return m.SessionTTL
	}
	return 0
}

func (m *UpdateUserRequest) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

func (m *UpdateUserRequest) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

type ListUserResponse struct {
	TotalCount int32              `protobuf:"varint,1,opt,name=totalCount" json:"totalCount,omitempty"`
	Result     []*GetUserResponse `protobuf:"bytes,2,rep,name=result" json:"result,omitempty"`
}

func (m *ListUserResponse) Reset()                    { *m = ListUserResponse{} }
func (m *ListUserResponse) String() string            { return proto.CompactTextString(m) }
func (*ListUserResponse) ProtoMessage()               {}
func (*ListUserResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{14} }

func (m *ListUserResponse) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *ListUserResponse) GetResult() []*GetUserResponse {
	if m != nil {
		return m.Result
	}
	return nil
}

type UserEmptyResponse struct {
}

func (m *UserEmptyResponse) Reset()                    { *m = UserEmptyResponse{} }
func (m *UserEmptyResponse) String() string            { return proto.CompactTextString(m) }
func (*UserEmptyResponse) ProtoMessage()               {}
func (*UserEmptyResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{15} }

type UpdateUserPasswordRequest struct {
	// The ID of the user for which to update the password.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// The new password to set.
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *UpdateUserPasswordRequest) Reset()                    { *m = UpdateUserPasswordRequest{} }
func (m *UpdateUserPasswordRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateUserPasswordRequest) ProtoMessage()               {}
func (*UpdateUserPasswordRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{16} }

func (m *UpdateUserPasswordRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdateUserPasswordRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// The request for branding
type BrandingRequest struct {
}

func (m *BrandingRequest) Reset()                    { *m = BrandingRequest{} }
func (m *BrandingRequest) String() string            { return proto.CompactTextString(m) }
func (*BrandingRequest) ProtoMessage()               {}
func (*BrandingRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{17} }

// The branding data.
type BrandingResponse struct {
	Logo         string `protobuf:"bytes,1,opt,name=logo" json:"logo,omitempty"`
	Registration string `protobuf:"bytes,2,opt,name=registration" json:"registration,omitempty"`
	Footer       string `protobuf:"bytes,3,opt,name=footer" json:"footer,omitempty"`
}

func (m *BrandingResponse) Reset()                    { *m = BrandingResponse{} }
func (m *BrandingResponse) String() string            { return proto.CompactTextString(m) }
func (*BrandingResponse) ProtoMessage()               {}
func (*BrandingResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{18} }

func (m *BrandingResponse) GetLogo() string {
	if m != nil {
		return m.Logo
	}
	return ""
}

func (m *BrandingResponse) GetRegistration() string {
	if m != nil {
		return m.Registration
	}
	return ""
}

func (m *BrandingResponse) GetFooter() string {
	if m != nil {
		return m.Footer
	}
	return ""
}

func init() {
	proto.RegisterType((*OrganizationLink)(nil), "api.OrganizationLink")
	proto.RegisterType((*ProfileRequest)(nil), "api.ProfileRequest")
	proto.RegisterType((*ProfileResponse)(nil), "api.ProfileResponse")
	proto.RegisterType((*ProfileSettings)(nil), "api.ProfileSettings")
	proto.RegisterType((*LoginRequest)(nil), "api.LoginRequest")
	proto.RegisterType((*LoginResponse)(nil), "api.LoginResponse")
	proto.RegisterType((*ListUserRequest)(nil), "api.ListUserRequest")
	proto.RegisterType((*UserRequest)(nil), "api.UserRequest")
	proto.RegisterType((*AddUserResponse)(nil), "api.AddUserResponse")
	proto.RegisterType((*UserSettings)(nil), "api.UserSettings")
	proto.RegisterType((*GetUserResponse)(nil), "api.GetUserResponse")
	proto.RegisterType((*AddUserRequest)(nil), "api.AddUserRequest")
	proto.RegisterType((*AddUserOrganization)(nil), "api.AddUserOrganization")
	proto.RegisterType((*UpdateUserRequest)(nil), "api.UpdateUserRequest")
	proto.RegisterType((*ListUserResponse)(nil), "api.ListUserResponse")
	proto.RegisterType((*UserEmptyResponse)(nil), "api.UserEmptyResponse")
	proto.RegisterType((*UpdateUserPasswordRequest)(nil), "api.UpdateUserPasswordRequest")
	proto.RegisterType((*BrandingRequest)(nil), "api.BrandingRequest")
	proto.RegisterType((*BrandingResponse)(nil), "api.BrandingResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for User service

type UserClient interface {
	// Get user list.
	List(ctx context.Context, in *ListUserRequest, opts ...grpc.CallOption) (*ListUserResponse, error)
	// Get data for a particular user.
	Get(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
	// Create a new user.
	Create(ctx context.Context, in *AddUserRequest, opts ...grpc.CallOption) (*AddUserResponse, error)
	// Update an existing user.
	Update(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UserEmptyResponse, error)
	// Delete a user.
	Delete(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UserEmptyResponse, error)
	// UpdatePassword updates a password.
	UpdatePassword(ctx context.Context, in *UpdateUserPasswordRequest, opts ...grpc.CallOption) (*UserEmptyResponse, error)
}

type userClient struct {
	cc *grpc.ClientConn
}

func NewUserClient(cc *grpc.ClientConn) UserClient {
	return &userClient{cc}
}

func (c *userClient) List(ctx context.Context, in *ListUserRequest, opts ...grpc.CallOption) (*ListUserResponse, error) {
	out := new(ListUserResponse)
	err := grpc.Invoke(ctx, "/api.User/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Get(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) {
	out := new(GetUserResponse)
	err := grpc.Invoke(ctx, "/api.User/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Create(ctx context.Context, in *AddUserRequest, opts ...grpc.CallOption) (*AddUserResponse, error) {
	out := new(AddUserResponse)
	err := grpc.Invoke(ctx, "/api.User/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Update(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UserEmptyResponse, error) {
	out := new(UserEmptyResponse)
	err := grpc.Invoke(ctx, "/api.User/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Delete(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UserEmptyResponse, error) {
	out := new(UserEmptyResponse)
	err := grpc.Invoke(ctx, "/api.User/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdatePassword(ctx context.Context, in *UpdateUserPasswordRequest, opts ...grpc.CallOption) (*UserEmptyResponse, error) {
	out := new(UserEmptyResponse)
	err := grpc.Invoke(ctx, "/api.User/UpdatePassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for User service

type UserServer interface {
	// Get user list.
	List(context.Context, *ListUserRequest) (*ListUserResponse, error)
	// Get data for a particular user.
	Get(context.Context, *UserRequest) (*GetUserResponse, error)
	// Create a new user.
	Create(context.Context, *AddUserRequest) (*AddUserResponse, error)
	// Update an existing user.
	Update(context.Context, *UpdateUserRequest) (*UserEmptyResponse, error)
	// Delete a user.
	Delete(context.Context, *UserRequest) (*UserEmptyResponse, error)
	// UpdatePassword updates a password.
	UpdatePassword(context.Context, *UpdateUserPasswordRequest) (*UserEmptyResponse, error)
}

func RegisterUserServer(s *grpc.Server, srv UserServer) {
	s.RegisterService(&_User_serviceDesc, srv)
}

func _User_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).List(ctx, req.(*ListUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Get(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Create(ctx, req.(*AddUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Update(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Delete(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/UpdatePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdatePassword(ctx, req.(*UpdateUserPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _User_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _User_List_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _User_Get_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _User_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _User_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _User_Delete_Handler,
		},
		{
			MethodName: "UpdatePassword",
			Handler:    _User_UpdatePassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

// Client API for Internal service

type InternalClient interface {
	// Log in a user
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	// Get the current user's profile
	Profile(ctx context.Context, in *ProfileRequest, opts ...grpc.CallOption) (*ProfileResponse, error)
	// Get the branding for the UI
	Branding(ctx context.Context, in *BrandingRequest, opts ...grpc.CallOption) (*BrandingResponse, error)
}

type internalClient struct {
	cc *grpc.ClientConn
}

func NewInternalClient(cc *grpc.ClientConn) InternalClient {
	return &internalClient{cc}
}

func (c *internalClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	out := new(LoginResponse)
	err := grpc.Invoke(ctx, "/api.Internal/Login", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) Profile(ctx context.Context, in *ProfileRequest, opts ...grpc.CallOption) (*ProfileResponse, error) {
	out := new(ProfileResponse)
	err := grpc.Invoke(ctx, "/api.Internal/Profile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) Branding(ctx context.Context, in *BrandingRequest, opts ...grpc.CallOption) (*BrandingResponse, error) {
	out := new(BrandingResponse)
	err := grpc.Invoke(ctx, "/api.Internal/Branding", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Internal service

type InternalServer interface {
	// Log in a user
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	// Get the current user's profile
	Profile(context.Context, *ProfileRequest) (*ProfileResponse, error)
	// Get the branding for the UI
	Branding(context.Context, *BrandingRequest) (*BrandingResponse, error)
}

func RegisterInternalServer(s *grpc.Server, srv InternalServer) {
	s.RegisterService(&_Internal_serviceDesc, srv)
}

func _Internal_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Internal/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_Profile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).Profile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Internal/Profile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).Profile(ctx, req.(*ProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_Branding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BrandingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).Branding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Internal/Branding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).Branding(ctx, req.(*BrandingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Internal_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Internal",
	HandlerType: (*InternalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _Internal_Login_Handler,
		},
		{
			MethodName: "Profile",
			Handler:    _Internal_Profile_Handler,
		},
		{
			MethodName: "Branding",
			Handler:    _Internal_Branding_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

func init() { proto.RegisterFile("user.proto", fileDescriptor4) }

var fileDescriptor4 = []byte{
	// 928 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0xcb, 0x6e, 0xe4, 0x44,
	0x14, 0x95, 0xdb, 0xdd, 0x8e, 0x73, 0x93, 0xe9, 0x47, 0xe5, 0x31, 0xc6, 0x9a, 0x44, 0xa1, 0x90,
	0x50, 0x2b, 0x42, 0x69, 0x14, 0x76, 0x83, 0x34, 0x52, 0x33, 0x8f, 0x68, 0x20, 0x1a, 0x82, 0x27,
	0xa3, 0x6c, 0x71, 0xe2, 0x8a, 0x29, 0x70, 0x57, 0x19, 0x57, 0x35, 0xe1, 0x21, 0x36, 0xac, 0xd8,
	0x23, 0x7e, 0x82, 0x6f, 0xe0, 0x13, 0x90, 0x58, 0xb0, 0x67, 0xc5, 0x2f, 0xb0, 0x47, 0x55, 0x2e,
	0xbb, 0xed, 0x4a, 0xba, 0x85, 0x84, 0x40, 0x62, 0xe7, 0x3a, 0x75, 0x7d, 0xea, 0xdc, 0x7b, 0x4f,
	0x5d, 0x1b, 0x60, 0x2e, 0x48, 0x71, 0x94, 0x17, 0x5c, 0x72, 0xe4, 0xc6, 0x39, 0x0d, 0x1f, 0xa4,
	0x9c, 0xa7, 0x19, 0x99, 0xc4, 0x39, 0x9d, 0xc4, 0x8c, 0x71, 0x19, 0x4b, 0xca, 0x99, 0x28, 0x43,
	0xf0, 0xcf, 0x0e, 0x0c, 0x3f, 0x2c, 0xd2, 0x98, 0xd1, 0xaf, 0x35, 0x7e, 0x4a, 0xd9, 0x67, 0xe8,
	0x4d, 0xe8, 0xf3, 0x06, 0xf6, 0xfc, 0x49, 0xe0, 0x1c, 0x38, 0x63, 0x37, 0xb2, 0x50, 0x74, 0x08,
	0xc3, 0x26, 0xf2, 0x22, 0x9e, 0x91, 0xa0, 0x73, 0xe0, 0x8c, 0xd7, 0xa3, 0x5b, 0x38, 0x0a, 0x60,
	0x8d, 0x8a, 0x69, 0x32, 0xa3, 0x2c, 0x70, 0x0f, 0x9c, 0xb1, 0x1f, 0x55, 0x4b, 0xf4, 0x00, 0xd6,
	0xaf, 0x0a, 0x12, 0x4b, 0x92, 0x4c, 0x65, 0xd0, 0xd5, 0xaf, 0x2f, 0x00, 0xb5, 0x3b, 0xcf, 0x13,
	0xb3, 0xdb, 0x2b, 0x77, 0x6b, 0x00, 0x0f, 0xa1, 0x7f, 0x56, 0xf0, 0x6b, 0x9a, 0x91, 0x88, 0x7c,
	0x3e, 0x27, 0x42, 0xe2, 0x9f, 0x1c, 0x18, 0xd4, 0x90, 0xc8, 0x39, 0x13, 0x04, 0x8d, 0xa1, 0xab,
	0xaa, 0xa2, 0xb3, 0xd8, 0x38, 0xde, 0x3e, 0x8a, 0x73, 0x7a, 0x74, 0x42, 0xe4, 0x2b, 0x41, 0x8a,
	0x2a, 0x26, 0xd2, 0x11, 0xe8, 0x5d, 0xb8, 0xd7, 0x54, 0x2e, 0x02, 0xf7, 0xc0, 0x1d, 0x6f, 0x1c,
	0xef, 0xe8, 0x57, 0xec, 0x3a, 0x45, 0xed, 0x58, 0xf4, 0x36, 0xf8, 0x82, 0x48, 0x49, 0x59, 0x2a,
	0x74, 0x1e, 0xd5, 0x51, 0x46, 0xce, 0x4b, 0xb3, 0x17, 0xd5, 0x51, 0xf8, 0xa3, 0x5a, 0x6b, 0xb5,
	0x89, 0x1e, 0x41, 0x98, 0x50, 0x11, 0x5f, 0x66, 0x64, 0x2a, 0x04, 0x4d, 0xd9, 0xd3, 0x2f, 0xa9,
	0x50, 0x3b, 0x4a, 0xac, 0xd0, 0x19, 0xf8, 0xd1, 0x8a, 0x08, 0xfc, 0x0c, 0x36, 0x4f, 0x79, 0x4a,
	0x99, 0xa9, 0x07, 0x0a, 0xc1, 0x57, 0x99, 0x31, 0xd5, 0x1b, 0x47, 0x97, 0xaf, 0x5e, 0xab, 0xbd,
	0x3c, 0x16, 0xe2, 0x86, 0x17, 0x89, 0xe9, 0x5b, 0xbd, 0xc6, 0xaf, 0xc3, 0x3d, 0xc3, 0x63, 0x8a,
	0x38, 0x04, 0xf7, 0xd3, 0x1b, 0x69, 0x38, 0xd4, 0x23, 0xbe, 0x80, 0xc1, 0x29, 0x15, 0xa6, 0x8c,
	0xe5, 0x69, 0xdb, 0xd0, 0xcb, 0xe8, 0x8c, 0x96, 0x61, 0xbd, 0xa8, 0x5c, 0xa0, 0x5d, 0xf0, 0xf8,
	0xf5, 0xb5, 0x20, 0x52, 0x9f, 0xd2, 0x8b, 0xcc, 0x4a, 0xe1, 0x82, 0xc4, 0xc5, 0xd5, 0x27, 0xda,
	0x12, 0xeb, 0x91, 0x59, 0xe1, 0x3d, 0xd8, 0x68, 0x92, 0xf6, 0xa1, 0x43, 0x13, 0x63, 0xc1, 0x0e,
	0x55, 0xd2, 0x06, 0xd3, 0x24, 0x69, 0x76, 0xef, 0x56, 0xc8, 0x2f, 0x0e, 0x6c, 0xaa, 0x80, 0xba,
	0xac, 0x56, 0x40, 0xab, 0x2c, 0x1d, 0xab, 0x2c, 0xfb, 0x00, 0x82, 0x08, 0x41, 0x39, 0x3b, 0x3f,
	0x3f, 0xd5, 0xd2, 0x7a, 0x51, 0x03, 0x69, 0x5a, 0xb9, 0xdb, 0xb6, 0x72, 0x08, 0x3e, 0x15, 0xd3,
	0x2b, 0x49, 0xbf, 0x20, 0xda, 0xab, 0x7e, 0x54, 0xaf, 0xdb, 0x36, 0xf7, 0x56, 0xda, 0x7c, 0xcd,
	0xb6, 0xf9, 0xaf, 0x0e, 0x0c, 0x2c, 0xc3, 0xfe, 0xcf, 0x33, 0xfa, 0xdd, 0x81, 0x7e, 0xdd, 0xc4,
	0x7f, 0xe4, 0xd4, 0x7f, 0x29, 0xb9, 0x47, 0xf6, 0x24, 0xf0, 0xf4, 0x24, 0x08, 0xf4, 0x8d, 0x36,
	0xca, 0x9b, 0x03, 0xc1, 0x1a, 0x06, 0xf8, 0x02, 0xb6, 0xee, 0x88, 0xfa, 0xdb, 0xa3, 0xb5, 0x21,
	0xba, 0xd3, 0x12, 0x8d, 0x7f, 0x74, 0x60, 0xf4, 0x4a, 0xd7, 0x71, 0xc5, 0x1d, 0xf9, 0xef, 0xdd,
	0x80, 0x3f, 0x86, 0xe1, 0x62, 0x1a, 0x18, 0x8f, 0xee, 0x03, 0x48, 0x2e, 0xe3, 0xec, 0x31, 0x9f,
	0xb3, 0x6a, 0x26, 0x34, 0x10, 0xf4, 0x16, 0x78, 0x05, 0x11, 0xf3, 0x4c, 0x0d, 0x06, 0x77, 0xe9,
	0x68, 0x36, 0x31, 0x78, 0x0b, 0x46, 0x0a, 0x7f, 0x3a, 0xcb, 0xe5, 0x57, 0xd5, 0x26, 0x3e, 0x81,
	0xd7, 0x16, 0xd5, 0x38, 0x33, 0x9e, 0x58, 0x51, 0x95, 0xa5, 0x03, 0x6f, 0x04, 0x83, 0xf7, 0x8a,
	0x98, 0x25, 0x94, 0xa5, 0xd5, 0xb7, 0xe4, 0x12, 0x86, 0x0b, 0xc8, 0xa4, 0x84, 0xa0, 0x9b, 0xf1,
	0x94, 0x1b, 0x87, 0xea, 0x67, 0x84, 0x61, 0xb3, 0x20, 0x29, 0x15, 0xb2, 0xd0, 0xed, 0x33, 0xd4,
	0x2d, 0x4c, 0xcd, 0xba, 0x6b, 0xce, 0x25, 0x29, 0xaa, 0x59, 0x57, 0xae, 0x8e, 0xff, 0x74, 0xa1,
	0xab, 0xa4, 0xa3, 0x13, 0xe8, 0xaa, 0xfa, 0xa1, 0xb2, 0x06, 0xd6, 0x60, 0x0d, 0x77, 0x2c, 0xd4,
	0x64, 0x8f, 0xbe, 0xfb, 0xed, 0x8f, 0x1f, 0x3a, 0x9b, 0x08, 0xf4, 0xe7, 0x5d, 0x75, 0x58, 0xa0,
	0x67, 0xe0, 0x9e, 0x10, 0x89, 0x86, 0xfa, 0x8d, 0x26, 0xc7, 0x9d, 0xd5, 0xc5, 0xf7, 0x35, 0xc5,
	0x08, 0x0d, 0x16, 0x14, 0x93, 0x6f, 0x68, 0xf2, 0x2d, 0x7a, 0x1f, 0xbc, 0xc7, 0xfa, 0x36, 0xa3,
	0xad, 0xa6, 0xe9, 0xdb, 0x6c, 0xd6, 0x20, 0xc6, 0x3b, 0x9a, 0x6d, 0x80, 0x1b, 0x82, 0x1e, 0x3a,
	0x87, 0xe8, 0x1c, 0xbc, 0xb2, 0x4b, 0x68, 0xb7, 0x94, 0x65, 0x1b, 0x38, 0xdc, 0xad, 0xe5, 0xb6,
	0xfb, 0x1b, 0x6a, 0xc2, 0xed, 0xd0, 0x96, 0xa7, 0x58, 0x3f, 0x00, 0xef, 0x09, 0xc9, 0x88, 0x24,
	0x77, 0x24, 0xbb, 0x8c, 0xcf, 0xa4, 0x7b, 0x78, 0x2b, 0xdd, 0x19, 0xf4, 0x4b, 0x55, 0x67, 0xf5,
	0x60, 0xb1, 0xa4, 0x5a, 0xee, 0x5a, 0x7a, 0xc4, 0x1b, 0xfa, 0x88, 0xbd, 0x30, 0xb0, 0x8e, 0x98,
	0x54, 0x5e, 0x7b, 0xe8, 0x1c, 0x1e, 0x7f, 0xdf, 0x01, 0xff, 0x39, 0x93, 0xea, 0x4a, 0x66, 0xe8,
	0x05, 0xf4, 0xf4, 0xc7, 0x16, 0x8d, 0xca, 0x36, 0x37, 0x3e, 0xe0, 0x21, 0x6a, 0x42, 0xe6, 0x84,
	0x7d, 0x7d, 0x42, 0x80, 0xb7, 0xf4, 0x09, 0xd4, 0xd0, 0x4c, 0x32, 0x15, 0xa4, 0x0a, 0xf3, 0x12,
	0xd6, 0xcc, 0x7f, 0x85, 0xe9, 0x5d, 0xfb, 0x27, 0x29, 0xdc, 0x6e, 0x83, 0x86, 0x75, 0x4f, 0xb3,
	0xde, 0x47, 0x3b, 0x6d, 0xd6, 0xdc, 0x30, 0x5d, 0x80, 0x5f, 0xdd, 0x06, 0x63, 0x52, 0xeb, 0xbe,
	0x18, 0x93, 0xda, 0x57, 0xa6, 0x52, 0x8b, 0x76, 0xdb, 0xbc, 0x97, 0x26, 0xee, 0xd2, 0xd3, 0xbf,
	0xa2, 0xef, 0xfc, 0x15, 0x00, 0x00, 0xff, 0xff, 0x48, 0x83, 0x71, 0x0a, 0xbb, 0x0a, 0x00, 0x00,
}
